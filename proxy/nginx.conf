worker_processes auto;
events { worker_connections 1024; }

http {
  resolver 127.0.0.11 ipv6=off valid=10s;

  # HTTP Server - This is where victims land when HTTPS is not available
  # Simulates the downgrade attack when user types https://example.com but gets HTTP
  server {
    listen 80;
    server_name _;

    # Log the attack for demonstration
    access_log /var/log/nginx/attack.log;

    location / {
        add_header Content-Type "text/html; charset=utf-8" always;
        add_header X-Attack-Vector "HTTPS-Downgrade-to-HTTP" always;
        add_header X-Original-Request "https://$host$request_uri" always;

        return 200 '<!DOCTYPE html>
<html><head><title>Connection Downgraded - Security Warning</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #fff3cd; }
  .warning { background: #f8d7da; padding: 15px; border: 1px solid #f5c6cb; margin: 15px 0; }
  .attack { background: #ffe6e6; padding: 15px; border: 1px solid #ff0000; margin: 15px 0; }
</style>
</head>
<body>
<h1>HTTPS Downgrade Attack in Progress</h1>

<div class="warning">
<h3>What just happened:</h3>
<ol>
<li>You requested: <strong>https://$host$request_uri</strong></li>
<li>DNS poisoning pointed you to attacker server</li>
<li>No HTTPS service running → Browser fell back to HTTP</li>
<li>You are now on an UNENCRYPTED connection!</li>
</ol>
</div>

<div class="attack">
<h3>Attack Demonstration:</h3>
<p>In a real attack, this HTTP page could:</p>
<ul>
<li>Steal your credentials in plaintext</li>
<li>Inject malicious scripts</li>
<li>Redirect you to a fake "secure" site</li>
<li>Intercept all your data</li>
</ul>
</div>

<h3>Next Steps:</h3>
<p><strong>The attacker will now redirect you to their "legitimate" HTTPS site...</strong></p>
<p><a href="/redirect-to-fake-https" style="padding: 10px 20px; background: #007cba; color: white; text-decoration: none;">
Continue to "Secure" Site →
</a></p>

<p><small>Current URL: $scheme://$host$request_uri</small></p>
</body></html>';
    }

    # Redirect to attacker's HTTPS site (with valid cert for their domain)
    location = /redirect-to-fake-https {
        # Redirect to the attacker's HTTPS site on port 8443
        return 302 https://$host:8443/victim-site;
    }

    # Direct credential harvesting on HTTP for demonstration
    location = /steal-http-creds {
        return 200 '<!DOCTYPE html>
<html><head><title>HTTP Credential Theft</title>
<style>body{font-family:sans-serif;padding:20px;background:#ffcccc;}</style>
</head>
<body>
<h2>HTTP Attack - Credentials Stolen!</h2>
<p><strong>Captured via unencrypted HTTP:</strong></p>
<ul>
<li>Username: <code>$arg_username</code></li>
<li>Password: <code>$arg_password</code></li>
<li>Method: Plaintext interception</li>
<li>Source: $remote_addr</li>
</ul>
<p>This happened because you were on HTTP instead of HTTPS!</p>
<p><a href="/redirect-to-fake-https">Now see the HTTPS version →</a></p>
</body></html>';
        }
    }
}